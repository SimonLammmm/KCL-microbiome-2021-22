---
title: "Choices of a programmer"
author: "Simon Lam"
date: "28 October 2021"
output: html_document
---

```{r setup, include=FALSE}

knitr::opts_chunk$set(echo = TRUE)
options(max.print = 20)

```

## Introduction

As an R programmer, you will have a number of choices to make during your analysis. There are many roads to Rome, and it is your individual choice as to how you wish to develop your developer skills. There are choices regarding which packages you want to install, which file formats you want to deal with, and how you deal with warnings and errors. All of this boils down to how you implement solutions to biological problems.

In today's course, we will explore data published in a recent paper. The exact nature of the study and data does not matter in order to understand today's course, but for those who are interested, the source study is linked here: https://doi.org/10.3390/biomedicines9101310.

The files for today's course can be downloaded from: https://github.com/SimonLammmm/KCL-microbiome-2021-22.

# My R crashed; what should I do?

### If R crashes during the course, run the following code and you'll be ready to pick up from where you left off:

```{r}

options(max.print = 20)
library(readxl)
library(writexl)
library(dplyr)
my_plaintext <- read.csv("terms.csv")
my_excel <- read_excel("terms.xlsx")
load("terms.RData")

```

If R hasn't crashed, then there's no need to run the above code.

## Reading and writing data to/from file

Before starting, install `readxl` and `writexl` using `install.packages(c("readxl", "writexl", "dplyr", "ggplot2", "ggpubr"))`.

To read plaintext files, use `read.csv()`.

To read Excel files, use `read_excel()` from the `readxl` package.

To read RData files, use `load()`.

TIP: Press Tab while your cursor is between the brackets of any function to see its usage.

```{r}



options(max.print = 20) # don't let R spam the console

library(readxl) # load the readxl package

my_plaintext <- read.csv("terms.csv") # read the plaintext file

my_excel <- read_excel("terms.xlsx") # read the excel file

load("terms.RData") # read the RData file

```

### Exercise 1

To write plaintext files, use `write.csv()`.

To write Excel files, use `write_xlsx()` from the `writexl` package.

To write RData files, use `save()`.

Complete the code below to save the `my_plaintext`, `my_excel`, and `my_rdata` objects to the files my_plaintext.csv, my_excel.xlsx, and my_rdata.RData, respectively.

EXTENSION: What factors will influence which file you'll choose to share with other people? Which is the best choice for 1) an R statistician? 2) a Python statistician? 3) a non-statistician? 

```{r}

library(writexl) # load the writexl package

write.csv(x = my_plaintext, file = "my_plaintext.csv") # save my_plaintext to the file "my_plaintext.csv"

write_xlsx(x = my_excel, path = "my_excel.xlsx") # save my_excel to the file "my_excel.xlsx"

save(my_rdata, file = "my_rdata.RData") # save my_rdata to the file "my_rdata.RData"

```

## Data types in R

When we load in our data, it's important to make sure that our data are stored as the correct data type.

Use `glimpse()` from the `dplyr` package to check the data types of each of the columns in `my_plaintext`, `my_excel`, and `my_rdata`. Do the data types make sense?

```{r}

library(dplyr) # load the dplyr package

glimpse(my_plaintext) # check the data types in my_plaintext

glimpse(my_excel) # check the data types in my_excel

glimpse(my_rdata) # check the data types in my_rdata

```

### Exercise 2

In `my_excel`, the Odds Ratio and Combined Score columns are numbers stored as characters. Complete the code to convert these columns into numeric data types using `as.numeric()`.

```{r}

my_excel$`Odds Ratio` <- as.numeric(my_excel$`Odds Ratio`) # convert the Odds Ratio column to numeric

my_excel$`Combined Score` <- as.numeric(my_excel$`Combined Score`) # convert the Combined Score column to numeric

glimpse(my_excel) # check the data types in my_excel again

```

## Subsetting with base R

Use the `$` operator to subset by column name.

Use the `[i,j]` operator to subset by (i,j) index.

Specify ranges using `:`.

You can combine `$` and `[i]` operators.

```{r}

my_plaintext$Term # gives us the Term column

my_plaintext[3,2] # gives us the element in the 3rd row and 2nd column

my_plaintext[3, ] # gives us the entire 3rd row

my_plaintext[ ,2] # gives us the entire 2nd column

my_plaintext[1:3,1:3] # what does this do?

my_plaintext$Term[2] # what does this do?

```

It is possible to specify `i` and `j` using rules rather than numbers.

Use `which()` to specify the indices of interest using numeric rules.

Use `grep()` to specify the indices of interest by matching text.

```{r}

idx <- which(my_plaintext$Adjusted.P.value < 1e-9) # stores the indices of the terms with adjusted p-value less than 10^-9 in a variable called idx

my_plaintext[idx, ] # returns entire rows for which adjusted p-value is less than 10^-9

idx2 <- grep("neuron", my_plaintext$Term) # stores the indices of the terms containing "neuron" in a variable called idx2

my_plaintext[idx2, ] # returns entire rows in which the terms contain "neuron"

```

### Exercise 3

Use base R functions to extract the rows in `my_excel` which have Odds Ratio greater than 200.

```{r}

idx3 <- which(my_excel$`Odds Ratio` > 200) # find the indices which have Odds Ratio greater than 200

my_excel[idx3, ] # return entire rows for those indices

```

Use base R functions to extract the rows in `my_excel` in which Term contains the text "membrane".

```{r}

idx4 <- grep("membrane", my_excel$Term) # find the indices for which Term includes the text "membrane"

my_excel[idx4, ] # return entire rows for those indices

```

## Subsetting with `dplyr`

Use the pipe operator `%>%` to use the output of the left-hand side as the input for the right-hand side.

Use the `select()` verb to subset entire columns by name or number.

Use the `filter()` verb to subset rows according to numeric or character rules.

```{r}

my_plaintext %>% glimpse()

my_plaintext %>% select(Term, 3, `Odds.Ratio`)

my_plaintext %>% filter(`Combined.Score` > 1000)

```

### Exercise 4

Use `dplyr` functions to extract the rows in `my_excel` which have Odds Ratio greater than 200

```{r}

my_excel %>% filter(`Odds Ratio` > 200)

```

Use `dplyr` functions to extract the rows in `my_excel` in which Term contains the text "membrane". (Advanced)

```{r}

my_excel %>% filter(grepl("membrane", Term))

```

Reason with yourself why needed to call `grepl()` within `filter()`.

### Free practice

Write code to extract all Terms in `my_excel` containing the text "neuron" for which P-value is less than 10^-4. It's your choice whether you use base R functions or `dplyr` functions!

```{r}

idx5 <- which(my_excel$`P-value` < 1e-4) # find the indices with P-value < 1e-4
my_excel_after_idx5 <- my_excel[idx5, ] # subset by idx5
idx6 <- grep("neuron", my_excel_after_idx5$Term) # find the indices with Term containing "neuron"
my_excel_after_idx6 <- my_excel_after_idx5[idx6, ] # subset by idx6
my_excel_after_idx6$Term # extract the Term column

my_excel %>% filter(`P-value` < 1e-4) %>% filter(grepl("neuron", Term)) %>% select(Term) # dplyr

```

## The `for()` loop

Iterate over a list using the `for()` loop.

This means doing the same set of commands for each item in the loop.

First, initialise a list of items that you're interested in.

Then, write the commands to be done of those items in a `for()` loop code block.

```{r}

my_interest <- c("neuron", "membrane", "development") # initialise a list of items to iterate over

for(item in my_interest) { # go through the items in the my_interest list one by one
    cat("I am interested in", item, "\n") # run these commands once per item
    cat(toupper(item), "IS NOW IN UPPERCASE\n")
}

```

You can iterate over a numerical range instead of items in a list.

```{r}

for(i in 1:10) {
    cat("I am thinking of the number", i, "\n")
}

```

You can iterate over a numerical range and use `i` as an index to subset data.

```{r}

for(i in 1:10) {
    cat("The", i, "th column in my_plaintext is called", names(my_plaintext)[i], "\n")
}

```

### Exercise 5

Use a `for()` loop to find all of the Terms in `my_excel` which contain: a) "neuron", b) "membrane", c) "development". It's your choice whether you want to use base R functions or `dplyr` for the subsetting!

```{r}

my_interest2 <- c("neuron", "membrane", "development")

# using base R
for(item in my_interest2) {
    idx8 <- grep(item, my_excel$Term)
    print(my_excel$Term[idx8])
}

# using dplyr
for(item in my_interest2) {
    my_excel %>% filter(grepl(item, Term)) %>% select(Term) %>% print()
}

# note: when inside a for loop, we need to call print() in order to output to the console

```

## Error handling

We need to understand why errors and warnings occur. We need to understand which warnings can or cannot be ignored. We need to know how to deal with errors and fix them.

Be warned. The following code will throw errors or warnings.

```{r}

try({
    read.csv(file = "non_existent_file.csv") # R can't find the file, so it threw an error and stopped execution
})

cat("\n")

try({
    my_warning <- c("hello", 1, 3e-9, FALSE) 
    as.integer(my_warning) # R gave an error because it can't convert all the data into integers. We need to reassess that that's what we really want to do
})

cat("\n")

try({
    library(ggpubr) # R gave some general package warnings. These are safe to ignore, but always make sure that your output is sensible when using the package functions
})

cat("\n")

try({
    my_excel[100] # for more complicated errors, search the error description online
})

```

### Exercise 6

Run the following commands, which will throw warnings or errors. Reason with yourself or check online to understand what happened. Change the code to clear the error.

```{r}

try({
    log(-1)
})

cat("\n")

try({
    library(ggplto2)
})

cat("\n")

try({
    my_excel %>% filter(c(TRUE, TRUE, TRUE))
})

```

## Extension: regular expressions

We use regular expressions to make pattern matching in text, for example when we use `filter()`, more powerful.

Consider we want to filter for Terms in `my_excel` which include "synapse" or "synaptic". We could do the following:

```{r}

my_excel %>% filter(grepl("synap", Term)) %>% select(Term) # filter my_excel for terms including "synapse" or "synaptic"

```

With regular expressions, we can make even more powerful filters. What does the following code do?

```{r}

my_excel %>% filter(grepl("regulation.+synap", Term)) %>% select(Term) # filter my_excel for terms including "regulation" and then "synapse" or "synaptic"

```

All of the terms that we found have "regulation" in them, and then some other characters, and then either "synapse" or "synaptic".

### Free practice

Find all of the terms in `my_excel` for which Overlap contains two digits, followed by a forward slash, followed by three digits.

```{r}

my_excel %>% filter(grepl("\\d{2}/\\d{3}", Overlap)) %>% select(Term)
# \\d{2} means match 2 digits
# / means match the forward slash
# \\d{3} means match 3 digits

```

Congratulations for reaching the end of this course!